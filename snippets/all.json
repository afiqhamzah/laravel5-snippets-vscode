{
  "Auth-check.sublime-snippet": {
    "prefix": "Auth::check",
    "body": [
      "Auth::check()"
    ],
    "description": "Determine if the current user is authenticated."
  },
  "Auth-guest.sublime-snippet": {
    "prefix": "Auth::guest",
    "body": [
      "Auth::guest()"
    ],
    "description": "Determine if the current user is a guest."
  },
  "Auth-logout.sublime-snippet": {
    "prefix": "Auth::logout",
    "body": [
      "Auth::logout();"
    ],
    "description": "Log the user out of the application."
  },
  "Auth-user.sublime-snippet": {
    "prefix": "Auth::user",
    "body": [
      "Auth::user()"
    ],
    "description": "Get the currently authenticated user."
  },
  "Auth-guard": {
    "prefix": "Auth::guard",
    "body": [
      "Auth::guard('${1:guardName}')$2"
    ],
    "description": "customize the \"guard\" that is used to authenticate and register users"
  },
  "Auth-attempt": {
    "prefix": "Auth::attempt",
    "body": [
      "Auth::attempt([${1:'email' => \\$email, 'password' => \\$password}])$2"
    ],
    "description": "Log by passing an array with key-value"
  },
  "Auth-login": {
    "prefix": "Auth::login",
    "body": [
      "Auth::login(${1:\\$user});$2"
    ],
    "description": "Log an existing user instance into your application"
  },
  "Auth-loginUsingId": {
    "prefix": "Auth::loginUsingId",
    "body": [
      "Auth::loginUsingId($1);$2"
    ],
    "description": "To log a user into the application by their ID"
  },
  "Auth-viaRemember": {
    "prefix": "Auth::viaRemember",
    "body": [
      "Auth::viaRemember()"
    ],
    "description": "Determine if the user was authenticated using the \"remember me\" cookie."
  },
  "Auth-routes": {
    "prefix": "Auth::routes",
    "body": [
      "Auth::routes();"
    ],
    "description": "Set authentication routes (v5.3)"
  },
  "Broadcast-channel": {
    "prefix": "Broadcast::channel",
    "body": "Broadcast::channel('${1}', ${2}::class);${3}",
    "description": "Broadcast Channel Classes"
  },
  "Cache-add.sublime-snippet": {
    "prefix": "Cache::add",
    "body": [
      "Cache::add('${1:key}', ${2:\\$value}, ${3:\\$ttl});$4"
    ],
    "description": "Store an item in the Cache if it doesn't exist."
  },
  "Cache-decrement.sublime-snippet": {
    "prefix": "Cache::decrement",
    "body": [
      "Cache::decrement('${1:key}', ${2:\\$amount});$3"
    ],
    "description": "Decrement a Cached value"
  },
  "Cache-flush.sublime-snippet": {
    "prefix": "Cache::flush",
    "body": [
      "Cache::flush();"
    ],
    "description": "Remove all items from the cache."
  },
  "Cache-forever.sublime-snippet": {
    "prefix": "Cache::forever",
    "body": [
      "Cache::forever('${1:key}', ${2:\\$value});$3"
    ],
    "description": "Store an item in the Cache Permanently"
  },
  "Cache-forget.sublime-snippet": {
    "prefix": "Cache::forget",
    "body": [
      "Cache::forget('${1:key}');$2"
    ],
    "description": "Remove an Item from the Cache"
  },
  "Cache-get.sublime-snippet": {
    "prefix": "Cache::get",
    "body": [
      "Cache::get('${1:key}', '${2:default}');$3"
    ],
    "description": "Retrieve an Item from the Cache"
  },
  "Cache-has.sublime-snippet": {
    "prefix": "Cache::has",
    "body": [
      "Cache::has('${1:key}')$2"
    ],
    "description": "Check for existence in Cache"
  },
  "Cache-increment.sublime-snippet": {
    "prefix": "Cache::increment",
    "body": [
      "Cache::increment('${1:key}', ${2:\\$amount});$3"
    ],
    "description": "Increment a Cached value"
  },
  "Cache-pull.sublime-snippet": {
    "prefix": "Cache::pull",
    "body": [
      "Cache::pull('${1:key}');$2"
    ],
    "description": "Pulling An Item From The Cache"
  },
  "Cache-put.sublime-snippet": {
    "prefix": "Cache::put",
    "body": [
      "Cache::put('${1:key}', ${2:\\$value}, ${3:\\$ttl});$4"
    ],
    "description": "Store an item in the Cache (key, value, ttl)"
  },
  "Cache-remember.sublime-snippet": {
    "prefix": "Cache::remember",
    "body": [
      "Cache::remember('${1:key}', ${2:\\$ttl}, function () {",
      "    $3",
      "});"
    ],
    "description": "Retrieve item or Store a default value if it doesn't exist"
  },
  "Cache-rememberForever.sublime-snippet": {
    "prefix": "Cache::rememberForever",
    "body": [
      "Cache::rememberForever('${1:key}', function () {",
      "    $2",
      "});"
    ],
    "description": "Retrieve item or Store a default value permanently"
  },
  "Cache-lock-get": {
    "prefix": "Cache::lock-get",
    "body": "Cache::lock('${1:lock-name}', ${2:60})->get()",
    "description": "obtaining arbitrary locks"
  },
  "Cache-lock-release": {
    "prefix": "Cache::lock-release",
    "body": "Cache::lock('${1:lock-name}')->release()",
    "description": "release locks"
  },
  "Cache-lock-block": {
    "prefix": "Cache::lock-block",
    "body": "Cache::lock('${1:lock-name}', ${2:60})->block(${3:10})",
    "description": "block until the lock becomes available"
  },
  "Form-checkbox": {
    "prefix": "Form::checkbox",
    "body": [
      "{!! Form::checkbox(${1:$$name}, ${2:$$value}, ${3:$$checked}, [${4:$$options}]) !!}"
    ],
    "description": "Create a checkbox input field."
  },
  "Form-close": {
    "prefix": "Form::close",
    "body": [
      "{!! Form::close(${1}) !!}"
    ],
    "description": "Closes a form tag"
  },
  "Form-date": {
    "prefix": "Form::date",
    "body": [
      "{!! Form::date(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a date input field"
  },
  "Form-datetime": {
    "prefix": "Form::datetime",
    "body": [
      "{!! Form::datetime(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a datetime input field"
  },
  "Form-datetimeLocal": {
    "prefix": "Form::datetimeLocal",
    "body": [
      "{!! Form::datetimeLocal(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a datetime-local input field"
  },
  "Form-email": {
    "prefix": "Form::email",
    "body": [
      "{!! Form::email(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create an e-mail input field"
  },
  "Form-file": {
    "prefix": "Form::file",
    "body": [
      "{!! Form::file(${1:$$name}, [${2:$$options}]) !!}"
    ],
    "description": "Create a file input field"
  },
  "Form-hidden": {
    "prefix": "Form::hidden",
    "body": [
      "{!! Form::hidden(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a hidden input field"
  },
  "Form-label": {
    "prefix": "Form::label",
    "body": [
      "{!! Form::label(${1:$$for}, ${2:$$text}, [${3:$$options}]) !!}"
    ],
    "description": "Create a form label element."
  },
  "Form-model": {
    "prefix": "Form::model",
    "body": [
      "{!! Form::model(${1:$$user}, [${2:$$options}]) !!}"
    ],
    "description": "Create a new model based form builder."
  },
  "Form-number": {
    "prefix": "Form::number",
    "body": [
      "{!! Form::number(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a number input field"
  },
  "Form-open": {
    "prefix": "Form::open",
    "body": [
      "{!! Form::open(${1}) !!}"
    ],
    "description": "Open up a new HTML form"
  },
  "Form-password": {
    "prefix": "Form::password",
    "body": [
      "{!! Form::password(${1:$$name}, [${2:$$options}]) !!}"
    ],
    "description": "Create a password input field"
  },
  "Form-radio": {
    "prefix": "Form::radio",
    "body": [
      "{!! Form::radio(${1:$$name}, ${2:$$value}, ${3:$$checked}, [${4:$$options}]) !!}"
    ],
    "description": "Create a radio button input field"
  },
  "Form-select": {
    "prefix": "Form::select",
    "body": [
      "{!! Form::select(${1:$$name}, ${2:$$list}, ${3:$$selected}, [${4:$$options}]) !!}"
    ],
    "description": "Create a select box field"
  },
  "Form-selectMonth": {
    "prefix": "Form::selectMonth",
    "body": [
      "{!! Form::selectMonth(${1:$$name}, ${2:$$selected}, [${3:$$options}]) !!}"
    ],
    "description": "Create a select month field"
  },
  "Form-selectRange": {
    "prefix": "Form::selectRange",
    "body": [
      "{!! Form::selectRange(${1:$$name}, ${2:$$min}, ${3:$$max}), ${4:$$selected}, [${5:$$options} !!}"
    ],
    "description": "Create a select range field"
  },
  "Form-submit": {
    "prefix": "Form::submit",
    "body": [
      "{!! Form::submit(${1:$$text}, [${2:$$options}]) !!}"
    ],
    "description": "Create a submit button element"
  },
  "Form-text": {
    "prefix": "Form::text",
    "body": [
      "{!! Form::text(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a text input field"
  },
  "Form-textarea": {
    "prefix": "Form::textarea",
    "body": [
      "{!! Form::textarea(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a textarea input field"
  },
  "Form-time": {
    "prefix": "Form::time",
    "body": [
      "{!! Form::time(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a time input field"
  },
  "Form-token": {
    "prefix": "Form::token",
    "body": [
      "{!! Form::token(${1}) !!}"
    ],
    "description": "Generate a hidden field with the current CSRF token"
  },
  "Form-url": {
    "prefix": "Form::url",
    "body": [
      "{!! Form::url(${1:$$name}, ${2:$$value}, [${3:$$options}]) !!}"
    ],
    "description": "Create a url input field"
  },
  "link_to": {
    "prefix": "link_to",
    "body": [
      "{!! link_to(${1:$url}, ${2:$title = null}, ${3:$attributes = []}, ${4:$secure = null}, ${5:$escape = true}) !!}"
    ],
    "description": "Generate an HTML link"
  },
  "link_to_asset": {
    "prefix": "link_to_asset",
    "body": [
      "{!! link_to_asset(${1:$url}, ${2:$title = null}, ${3:$attributes = []}, ${4:$secure = null}) !!}"
    ],
    "description": "Generate an HTML link to an asset"
  },
  "link_to_route": {
    "prefix": "link_to_route",
    "body": [
      "{!! link_to_route(${1:$name}, ${2:$title = null}, ${3:$parameters = []}, ${4:$attributes = []}) !!}"
    ],
    "description": "Generate an HTML link to a named route"
  },
  "link_to_action": {
    "prefix": "link_to_action",
    "body": [
      "{!! link_to_action(${1:$action}, ${2:$title = null}, ${3:$parameters = []}, ${4:$attributes = []}) !!}"
    ],
    "description": "Generate an HTML link to a controller action"
  },
  "Config-all.sublime-snippet": {
    "prefix": "Config::all",
    "body": [
      "Config::all();"
    ],
    "description": "Get all of the configuration items for the application."
  },
  "Config-get.sublime-snippet": {
    "prefix": "Config::get",
    "body": [
      "Config::get('${1:key}', '${2:default}');$3"
    ],
    "description": "Get the specified configuration value."
  },
  "Config-has.sublime-snippet": {
    "prefix": "Config::has",
    "body": [
      "Config::has('${1:key}')$2"
    ],
    "description": "Determine if the given configuration value exists."
  },
  "Config-set.sublime-snippet": {
    "prefix": "Config::set",
    "body": [
      "Config::set('${1:key}', ${2:\\$value});$3"
    ],
    "description": "Set a given configuration value."
  },
  "Config-setMany.sublime-snippet": {
    "prefix": "Config::setMany",
    "body": [
      "Config::set([",
      "    '${1:key}' => ${2:\\$value},$3",
      "]);$4"
    ],
    "description": "Set a given configuration value."
  },
  "Command-anticipate.sublime-snippet": {
    "prefix": "Console::anticipate",
    "body": [
      "\\$this->anticipate('${1:Message}');$2"
    ],
    "description": "Give the user options for repsonse"
  },
  "Command-ask.sublime-snippet": {
    "prefix": "Console::ask",
    "body": [
      "\\$this->ask('${1:Question}');$2"
    ],
    "description": "Prompts the user with a question in the console"
  },
  "Command-choice.sublime-snippet": {
    "prefix": "Console::choice",
    "body": [
      "\\$this->choice('${1:Question?}', [${2'Choice1', 'Choice2'}], ${3:\\$default});$4"
    ],
    "description": "Give the user a predefined set of choices"
  },
  "Command-comment.sublime-snippet": {
    "prefix": "Console::comment",
    "body": [
      "\\$this->comment('${1:Message}');$2"
    ],
    "description": "Log a comment to the console"
  },
  "Command-confirm.sublime-snippet": {
    "prefix": "",
    "body": [
      "\\$this->confirm('${1:Do you wish to continue? [Y|N]}');$2"
    ],
    "description": "Logs a confirmation prompt to the console"
  },
  "Command-error.sublime-snippet": {
    "prefix": "Console::error",
    "body": [
      "\\$this->error('${1:Message}');$2"
    ],
    "description": "Log error to the console in red"
  },
  "Command-info.sublime-snippet": {
    "prefix": "Console::info",
    "body": [
      "\\$this->info('${1:Message}');$2"
    ],
    "description": "Log information to the console in green"
  },
  "Command-line.sublime-snippet": {
    "prefix": "Console::line",
    "body": [
      "\\$this->line('${1:Display this on the screen}');$2"
    ],
    "description": "Log plain information to the console"
  },
  "Command-option.sublime-snippet": {
    "prefix": "Console::option",
    "body": [
      "\\$this->option('$1');$2"
    ],
    "description": "Get an option from constructor"
  },
  "Command-question.sublime-snippet": {
    "prefix": "Console::question",
    "body": [
      "\\$this->question('${1:Message}');$2"
    ],
    "description": "Logs a question to the console"
  },
  "Command-secret.sublime-snippet": {
    "prefix": "Console::secret",
    "body": [
      "\\$this->secret('${1:What is the password?}');$2"
    ],
    "description": "Prompt the user for hidden input"
  },
  "Command-table.sublime-snippet": {
    "prefix": "Console::table",
    "body": [
      "\\$this->table('${1:\\$header}, ${2:\\$row}');$3"
    ],
    "description": "Prints a nicely formatted table to the console"
  },
  "Command-warn.sublime-snippet": {
    "prefix": "Console::warn",
    "body": [
      "\\$this->warn('${1:Message}');$2"
    ],
    "description": "Logs a warn message to the console"
  },
  "Cookie-forever.sublime-snippet": {
    "prefix": "Cookie::forever",
    "body": [
      "\\$response->withCookie(cookie()->forever('${1:key}', ${2:\\$value}));$3"
    ],
    "description": "Make a Permanent Cookie"
  },
  "Cookie-get.sublime-snippet": {
    "prefix": "Cookie::get",
    "body": [
      "\\$request->cookie('${1:key}');$2"
    ],
    "description": "Retrieve a Cookie value"
  },
  "Cookie-set.sublime-snippet": {
    "prefix": "Cookie::set",
    "body": [
      "\\$response->withCookie(cookie('${1:key}', ${2:\\$value}));$3"
    ],
    "description": "Attach a Cookie to a Response."
  },
  "Crypt-decrypt.sublime-snippet": {
    "prefix": "Crypt::decrypt",
    "body": [
      "try {",
      "    ${1:\\$decrypted} = Crypt::decrypt(${2:\\$encryptedValue});",
      "} catch (Illuminate\\Contracts\\Encryption\\DecryptException $e) {",
      "    $3",
      "}$4"
    ],
    "description": "Decrypt a value"
  },
  "Crypt-encrypt.sublime-snippet": {
    "prefix": "Crypt::encrypt",
    "body": [
      "Crypt::encrypt(${1:\\$value});$2"
    ],
    "description": "Encrypt a value"
  },
  "DB-delete.sublime-snippet": {
    "prefix": "DB::delete",
    "body": [
      "DB::delete(${1:'delete users where name = ?'}${2:, ['John']})$3"
    ],
    "description": "Run an delete statement against the database."
  },
  "DB-insert.sublime-snippet": {
    "prefix": "DB::insert",
    "body": [
      "DB::insert(${1:'insert into users (id, name) values (?, ?)'}${2:, [1, 'Dayle']})$3"
    ],
    "description": "Run an insert statement against the database."
  },
  "DB-select.sublime-snippet": {
    "prefix": "DB::select",
    "body": [
      "DB::select(${1:'select * from users where active = ?'}${2:, [1]})$3"
    ],
    "description": "Run a select statement against the database."
  },
  "DB-statement.sublime-snippet": {
    "prefix": "DB::select",
    "body": [
      "DB::statement(${1:'drop table users'})$2"
    ],
    "description": "Execute an SQL statement and return the boolean result."
  },
  "DB-transaction-begin.sublime-snippet": {
    "prefix": "DB::transaction_begin",
    "body": [
      "DB::beginTransaction();"
    ],
    "description": "Start a new database transaction."
  },
  "DB-transaction-commit.sublime-snippet": {
    "prefix": "DB::transaction_commit",
    "body": [
      "DB::commit();"
    ],
    "description": "Commit the active database transaction."
  },
  "DB-transaction-rollback.sublime-snippet": {
    "prefix": "DB::transaction_rollback",
    "body": [
      "DB::rollback();"
    ],
    "description": "Rollback the active database transaction."
  },
  "DB-transaction.sublime-snippet": {
    "prefix": "DB::transaction",
    "body": [
      "DB::transaction(function () {",
      "    $1",
      "});$2"
    ],
    "description": "Execute a Closure within a transaction."
  },
  "DB-update.sublime-snippet": {
    "prefix": "DB::update",
    "body": [
      "DB::update(${1:'update users set votes = 100 where name = ?'}${2:, ['John']});$3"
    ],
    "description": "Run an update statement against the database."
  },
  "DB-table": {
    "prefix": "DB::table",
    "body": [
      "DB::table('${1:users}')$2"
    ],
    "description": "Retrieving rows from a table"
  },
  "Event-createClassListener.sublime-snippet": {
    "prefix": "Event::createClassListener",
    "body": [
      "Event::createClassListener(${1:listener});$2"
    ],
    "description": "Create a class based listener using the IoC container."
  },
  "Event-fire.sublime-snippet": {
    "prefix": "Event::fire",
    "body": [
      "Event::fire(${1:new MyCustomEvent()});$2"
    ],
    "description": "Fire an event and call the listeners."
  },
  "Event-firing.sublime-snippet": {
    "prefix": "Event::firing",
    "body": [
      "Event::firing();"
    ],
    "description": "Get the event that is currently firing."
  },
  "Event-flush.sublime-snippet": {
    "prefix": "Event::flush",
    "body": [
      "Event::flush('${1:event}');$2"
    ],
    "description": "Flush a set of pushed events."
  },
  "Event-forget.sublime-snippet": {
    "prefix": "Event::forget",
    "body": [
      "Event::forget('${1:event}');$2"
    ],
    "description": "Remove a set of listeners from the dispatcher."
  },
  "Event-getListeners.sublime-snippet": {
    "prefix": "Event::getListeners",
    "body": [
      "Event::getListeners('${1:eventName}');$2"
    ],
    "description": "Get all of the listeners for a given event name."
  },
  "Event-hasListeners.sublime-snippet": {
    "prefix": "Event::hasListeners",
    "body": [
      "Event::hasListeners('${1:eventName}');$2"
    ],
    "description": "Determine if a given event has listeners."
  },
  "Event-listen.sublime-snippet": {
    "prefix": "Event::listen",
    "body": [
      "Event::listen(${1:events}, ${2:listener}, ${3:priority});$4"
    ],
    "description": "Register an event listener with the dispatcher."
  },
  "Event-makeListener.sublime-snippet": {
    "prefix": "Event::makeListener",
    "body": [
      "Event::makeListener(${1:listener});$2"
    ],
    "description": "Register an event listener with the dispatcher."
  },
  "Event-push.sublime-snippet": {
    "prefix": "Event::push",
    "body": [
      "Event::push(${1:event}, ${2:payload});$3"
    ],
    "description": "Register an event and payload to be fired later."
  },
  "Event-subscribe.sublime-snippet": {
    "prefix": "Event::subscribe",
    "body": [
      "Event::subscribe(${1:subscriber});$2"
    ],
    "description": "Register an event subscriber with the dispatcher."
  },
  "Event-until.sublime-snippet": {
    "prefix": "Event::until",
    "body": [
      "Event::until(${1:event}, ${2:payload});$3"
    ],
    "description": "Fire an event until the first non-null response is returned."
  },
  "Hash-check.sublime-snippet": {
    "prefix": "Hash::check",
    "body": [
      "Hash::check(${1:\\$value}, ${2:\\$hashedValue})$3"
    ],
    "description": "Check the given plain value against a hash."
  },
  "Hash-make.sublime-snippet": {
    "prefix": "Hash::make",
    "body": [
      "Hash::make(${1:\\$value})$2"
    ],
    "description": "Hash the given value."
  },
  "Hash-needsRehash.sublime-snippet": {
    "prefix": "Hash::needsRehash",
    "body": [
      "if (Hash::needsRehash(${1:\\$hashedValue}))",
      "{",
      "    ${2:\\$hashed} = Hash::make(${3:\\$value});",
      "}$4"
    ],
    "description": "Check if the given hash has been hashed using the given options."
  },
  "Helper-array-add.sublime-snippet": {
    "prefix": "Helper::array_add",
    "body": [
      "array_add(${1:\\$array}, ${2:'key'}, ${3:'value'})$4"
    ],
    "description": "Add an element to an array using \"dot\" notation if it doesn't exist."
  },
  "Helper-array-collapse.sublime-snippet": {
    "prefix": "Helper::array_collapse",
    "body": [
      "array_collapse(${1:\\$array})$2"
    ],
    "description": "Collapse an array of arrays into a single array."
  },
  "Helper-array-data_get.sublime-snippet": {
    "prefix": "Helper::array-data_get",
    "body": [
      "data_get(${1:\\$array}, ${2:'names.john'}, ${3:'default'})$4"
    ],
    "description": "Get an item from an array using \"dot\" notation."
  },
  "Helper-array-divide.sublime-snippet": {
    "prefix": "Helper::array_divide",
    "body": [
      "list(${1:\\$keys}, ${2:\\$values}) = array_divide(${3:\\$array})$4"
    ],
    "description": "Divide an array into two arrays. One with keys and the other with values."
  },
  "Helper-array-dot.sublime-snippet": {
    "prefix": "Helper::array_dot",
    "body": [
      "array_dot(${1:\\$array})$2"
    ],
    "description": "Flatten a multi-dimensional associative array with dots."
  },
  "Helper-array-end.sublime-snippet": {
    "prefix": "Helper::array-last",
    "body": [
      "last(${1:\\$array)$2"
    ],
    "description": "Get the last element of an array. Useful for method chaining."
  },
  "Helper-array-except.sublime-snippet": {
    "prefix": "Helper::array_except",
    "body": [
      "array_except(${1:\\$array}, ${2:['key', 'otherKey']})$3"
    ],
    "description": "Get all of the given array except for a specified array of items."
  },
  "Helper-array-first.sublime-snippet": {
    "prefix": "Helper::array_first",
    "body": [
      "array_first(${1:\\$array}, function (${2:\\$key}, ${3:\\$value}) {",
      "    return ${4:\\$value >= 150;}",
      "});$5"
    ],
    "description": "Return the first element in an array passing a given truth test."
  },
  "Helper-array-flatten.sublime-snippet": {
    "prefix": "Helper::array_flatten",
    "body": [
      "array_flatten(${1:\\$array})$2"
    ],
    "description": "Will flatten a multi-dimensional array into a single level."
  },
  "Helper-array-forget.sublime-snippet": {
    "prefix": "Helper::array_forget",
    "body": [
      "array_forget(${1:\\$array}, ${2:'names.joe'})$3"
    ],
    "description": "Remove one or many array items from a given array using \"dot\" notation."
  },
  "Helper-array-get.sublime-snippet": {
    "prefix": "Helper::array_get",
    "body": [
      "array_get(${1:\\$array}, ${2:'names.john'}, ${3:'default'})$4"
    ],
    "description": "Get an item from an array using \"dot\" notation."
  },
  "Helper-array-has.sublime-snippet": {
    "prefix": "Helper::array_has",
    "body": [
      "array_has(${1:\\$array}, ${2:key})$3"
    ],
    "description": "Check if an item exists in an array using \"dot\" notation."
  },
  "Helper-array-head.sublime-snippet": {
    "prefix": "Helper::array-head",
    "body": [
      "head(${1:\\$array})$2"
    ],
    "description": "Get the first element of an array. Useful for method chaining."
  },
  "Helper-array-last.sublime-snippet": {
    "prefix": "Helper::array_last",
    "body": [
      "array_last(${1:\\$array}, function (${2:\\$key}, ${3:\\$value}) {",
      "    return ${4:\\$value >= 150;}",
      "});$5"
    ],
    "description": "Return the last element in an array passing a given truth test."
  },
  "Helper-array-only.sublime-snippet": {
    "prefix": "Helper::array_only",
    "body": [
      "array_only(${1:\\$array}, ${2:['key', 'otherKey']})$3"
    ],
    "description": "Get a subset of the items from the given array."
  },
  "Helper-array-pluck.sublime-snippet": {
    "prefix": "Helper::array_pluck",
    "body": [
      "array_pluck(${1:\\$array}, ${2:'value'})$3"
    ],
    "description": "Pluck an array of values from an array."
  },
  "Helper-array-prepend.sublime-snippet": {
    "prefix": "Helper::array_prepend",
    "body": [
      "array_prepend(${1:\\$array}, ${2:'value'})$3"
    ],
    "description": "Push an item onto the beginning of an array."
  },
  "Helper-array-pull.sublime-snippet": {
    "prefix": "Helper::array_pull",
    "body": [
      "array_pull(${1:\\$array}, ${2:'value'})$3"
    ],
    "description": "Get a value from the array, and remove it."
  },
  "Helper-array-set.sublime-snippet": {
    "prefix": "Helper::array_set",
    "body": [
      "array_set(${1:\\$array}, ${2:'products.desk.price'}, ${3:200})$4"
    ],
    "description": "Set an array item to a given value using \"dot\" notation."
  },
  "Helper-array-sort-recursive.sublime-snippet": {
    "prefix": "Helper::array_sort_recursive",
    "body": [
      "array_sort_recursive(${1:\\$array});$2"
    ],
    "description": "Recursively sort an array by keys and values."
  },
  "Helper-array-sort.sublime-snippet": {
    "prefix": "Helper::array_sort",
    "body": [
      "array_values(array_sort(${1:\\$array}, function (${2:\\$key}, ${3:\\$value}) {",
      "    return ${3:\\$value}['${4:name}'];",
      "}));$5"
    ],
    "description": "Sort the array using the given callback."
  },
  "Helper-array-where.sublime-snippet": {
    "prefix": "Helper::array_where",
    "body": [
      "array_where(${2:\\$array}, function (${3:\\$key}, ${4:\\$value}) {",
      "    return ${4:is_string(\\$value);}",
      "});$5"
    ],
    "description": "Filter the array using the given callback."
  },
  "Helper-misc-class_uses-recursive.sublime-snippet": {
    "prefix": "Helper::misc-class_uses_recursive",
    "body": [
      "class_uses_recursive(${1:'Foo\\Bar\\Baz'})$2"
    ],
    "description": "Returns all traits used by a class, its subclasses and trait of their traits."
  },
  "Helper-misc-collect.sublime-snippet": {
    "prefix": "Helper::misc-collect",
    "body": [
      "collect(${1:'Foo\\Bar\\Baz'})$2"
    ],
    "description": "Create a collection from the given value."
  },
  "Helper-misc-csrf_field.sublime-snippet": {
    "prefix": "Helper::misc-csrf_field",
    "body": [
      "csrf_field()"
    ],
    "description": "Get the value of the current CSRF token."
  },
  "Helper-misc-csrf_token.sublime-snippet": {
    "prefix": "Helper::misc-csrf_token",
    "body": [
      "csrf_token()"
    ],
    "description": "Get the value of the current CSRF token."
  },
  "Helper-misc-dd.sublime-snippet": {
    "prefix": "Helper::misc-dd",
    "body": [
      "dd(${1:\\$value});$2"
    ],
    "description": "Dump the passed variables and end the script."
  },
  "Helper-misc-object_get.sublime-snippet": {
    "prefix": "Helper::misc-object_get",
    "body": [
      "object_get(${1:\\$object, ${2:'names.john'}, ${3:'default'})$4"
    ],
    "description": "Get an item from an object using \"dot\" notation."
  },
  "Helper-misc-trait_uses-recursive.sublime-snippet": {
    "prefix": "Helper::misc-trait_uses_recursive",
    "body": [
      "trait_uses_recursive(${1:'Foo\\Bar\\Baz'})$2"
    ],
    "description": "Returns all traits used by a trait and its traits."
  },
  "Helper-path-app.sublime-snippet": {
    "prefix": "Helper::path-app",
    "body": [
      "app_path()"
    ],
    "description": "Get the fully qualified path to the app directory."
  },
  "Helper-path-base.sublime-snippet": {
    "prefix": "Helper::path-base",
    "body": [
      "base_path(${1:'file'})$2"
    ],
    "description": "Get the fully qualified path to the root of the application install."
  },
  "Helper-path-config.sublime-snippet": {
    "prefix": "Helper::path-config",
    "body": [
      "config_path()"
    ],
    "description": "Get the fully qualified path to the app directory."
  },
  "Helper-path-elixir.sublime-snippet": {
    "prefix": "Helper::path-elixir",
    "body": [
      "elixir('${1:file}')$2"
    ],
    "description": "Get the path to the versionned Elixir file."
  },
  "Helper-path-public.sublime-snippet": {
    "prefix": "Helper::path-public",
    "body": [
      "public_path()"
    ],
    "description": "Get the fully qualified path to the public directory."
  },
  "Helper-path-storage.sublime-snippet": {
    "prefix": "Helper::path-storage",
    "body": [
      "storage_path(${1:'file'})$2"
    ],
    "description": "Get the fully qualified path to the app/storage directory."
  },
  "Helper-strings-camel_case.sublime-snippet": {
    "prefix": "Helper::strings-camel_case",
    "body": [
      "camel_case(${1:'foo_bar'})$2"
    ],
    "description": "Convert a value to camel case."
  },
  "Helper-strings-class_basename.sublime-snippet": {
    "prefix": "Helper::strings-class_basename",
    "body": [
      "class_basename(${1:'Foo\\Bar\\Baz'})$2"
    ],
    "description": "Get the class \"basename\" of the given object / class."
  },
  "Helper-strings-e.sublime-snippet": {
    "prefix": "Helper::strings-e",
    "body": [
      "e(${1:'<html>foo</html>'})$2"
    ],
    "description": "Escape HTML entities in a string."
  },
  "Helper-strings-ends_with.sublime-snippet": {
    "prefix": "Helper::strings-ends_with",
    "body": [
      "ends_with(${1:'haystack'}, ${2:'needles'})$3"
    ],
    "description": "Determine if a given string ends with a given substring."
  },
  "Helper-strings-snake_case.sublime-snippet": {
    "prefix": "Helper::strings-snake_case",
    "body": [
      "snake_case(${1:'fooBar'})$2"
    ],
    "description": "Convert the given string to snake_case."
  },
  "Helper-strings-starts_with.sublime-snippet": {
    "prefix": "Helper::strings-starts_with",
    "body": [
      "starts_with(${1:'haystack'}, ${2:'needle'})$3"
    ],
    "description": "Determine if the given haystack begins with the given needle."
  },
  "Helper-strings-str_contains.sublime-snippet": {
    "prefix": "Helper::strings-str_contains",
    "body": [
      "str_contains(${1:'This is my name'}, ${2:'my'})$3"
    ],
    "description": "Determine if the given haystack contains the given needle."
  },
  "Helper-strings-str_finish.sublime-snippet": {
    "prefix": "Helper::strings-str_finish",
    "body": [
      "str_finish(${1:'this/string'}, ${2:'/'})$3"
    ],
    "description": "Determine if a given string matches a given pattern. Asterisks may be used to indicate wildcards."
  },
  "Helper-strings-str_is.sublime-snippet": {
    "prefix": "Helper::strings-str_is",
    "body": [
      "str_is(${1:'foo*'}, ${2:'foobar'})$3"
    ],
    "description": "Add a single instance of the given needle to the haystack. Remove any extra instances."
  },
  "Helper-strings-str_limit.sublime-snippet": {
    "prefix": "Helper::strings-str_limit",
    "body": [
      "str_limit(${1:\\$value}, ${2:100})$3"
    ],
    "description": "Limit the number of characters in a string."
  },
  "Helper-strings-str_random.sublime-snippet": {
    "prefix": "Helper::strings-str_random",
    "body": [
      "str_random(${1:40})$2"
    ],
    "description": "Generate a random string of the given length."
  },
  "Helper-strings-str_singular.sublime-snippet": {
    "prefix": "Helper::strings-str_singular",
    "body": [
      "str_singular(${1:'string'})$2"
    ],
    "description": "Convert a string to its singular form (English only)."
  },
  "Helper-strings-str_slug.sublime-snippet": {
    "prefix": "Helper::strings-str_slug",
    "body": [
      "str_slug(${1:'fooBar'})$2"
    ],
    "description": "Generate a URL friendly \"slug\" from a given string."
  },
  "Helper-strings-studly_case.sublime-snippet": {
    "prefix": "Helper::strings-studly_case",
    "body": [
      "studly_case(${1:'foo_bar'})$2"
    ],
    "description": "Convert the given string to StudlyCase."
  },
  "Helper-strings-title_case.sublime-snippet": {
    "prefix": "Helper::strings-title_case",
    "body": [
      "title_case(${1:'fooBar'})$2"
    ],
    "description": "Convert a value to title case."
  },
  "Helper-strings-trans.sublime-snippet": {
    "prefix": "Helper::strings-trans",
    "body": [
      "trans(${1:'validation.required'})$2"
    ],
    "description": "Translate a given language line. Alias of Lang::get."
  },
  "Helper-strings-trans_choice.sublime-snippet": {
    "prefix": "Helper::strings-trans_choice",
    "body": [
      "trans_choice(${1:'foo.bar'}, ${2:\\$count})$3"
    ],
    "description": "Translate a given language line with inflection. Alias of Lang::choice."
  },
  "Helper-strings_plural.sublime-snippet": {
    "prefix": "Helper::strings-str_plural",
    "body": [
      "str_plural(${1:'string'})$2"
    ],
    "description": "Convert a string to its plural form (English only)."
  },
  "Helper-url-action.sublime-snippet": {
    "prefix": "Helper::url-action",
    "body": [
      "action(${1:'HomeController@getIndex'}, ${2:\\$params})$3"
    ],
    "description": "Generate a URL for a given controller action."
  },
  "Helper-url-asset.sublime-snippet": {
    "prefix": "Helper::url-asset",
    "body": [
      "asset(${1:'img/photo.jpg'})$2"
    ],
    "description": "Generate a URL for an asset."
  },
  "Helper-url-route.sublime-snippet": {
    "prefix": "Helper::url-route",
    "body": [
      "route(${1:'routeName'}, ${2:\\$params})$3"
    ],
    "description": "Generate a URL for a given named route."
  },
  "Helper-url-secure_asset.sublime-snippet": {
    "prefix": "Helper::url-secure_asset",
    "body": [
      "secure_asset(${1:'foo/bar'}, ${2:\\$title}, ${3:\\$attributes})$4"
    ],
    "description": "Generate a HTML link to the given asset using HTTPS."
  },
  "Helper-url-secure_url.sublime-snippet": {
    "prefix": "Helper::secure_url",
    "body": [
      "secure_url(${1:'foo/bar'}, ${2:\\$parameters})$3"
    ],
    "description": "Generate a fully qualified URL to a given path using HTTPS."
  },
  "Helper-url.sublime-snippet": {
    "prefix": "Helper::url-url",
    "body": [
      "url(${1:'foo/bar'}, ${2:\\$parameters}, ${3:\\$secure})$4"
    ],
    "description": "Generate a fully qualified URL to the given path."
  },
  "Helper-dd.sublime-snippet": {
    "prefix": "Helper::dd",
    "body": [
      "dd($1);"
    ],
    "description": "Die and dump helper"
  },
  "Log-alert.sublime-snippet": {
    "prefix": "Log::alert",
    "body": [
      "Log::alert('${1:message}');$2"
    ],
    "description": "Log an alert message to the logs."
  },
  "Log-critical.sublime-snippet": {
    "prefix": "Log::critical",
    "body": [
      "Log::critical('${1:message}');$2"
    ],
    "description": "Log a critical message to the logs."
  },
  "Log-debug.sublime-snippet": {
    "prefix": "Log::debug",
    "body": [
      "Log::debug('${1:message}');$2"
    ],
    "description": "Log a debug message to the logs."
  },
  "Log-emergency.sublime-snippet": {
    "prefix": "Log::emergency",
    "body": [
      "Log::emergency('${1:message}');$2"
    ],
    "description": "Log an emergency message to the logs."
  },
  "Log-error.sublime-snippet": {
    "prefix": "Log::error",
    "body": [
      "Log::error('${1:message}');$2"
    ],
    "description": "Log an error message to the logs."
  },
  "Log-info.sublime-snippet": {
    "prefix": "Log::info",
    "body": [
      "Log::info('${1:message}');$2"
    ],
    "description": "Log an informational message to the logs."
  },
  "Log-log.sublime-snippet": {
    "prefix": "Log::log",
    "body": [
      "Log::log('${1:level}', '${2:message}');$3"
    ],
    "description": "Log a message to the logs."
  },
  "Log-notice.sublime-snippet": {
    "prefix": "Log::notice",
    "body": [
      "Log::notice(${1:message});$2"
    ],
    "description": "Log a notice to the logs."
  },
  "Log-useDailyFiles.sublime-snippet": {
    "prefix": "Log::useDailyFiles",
    "body": [
      "Log::useDailyFiles('${1:path}', ${2:days}, '${3:level}');$4"
    ],
    "description": "Register a daily file log handler."
  },
  "Log-useFiles.sublime-snippet": {
    "prefix": "Log::useFiles",
    "body": [
      "Log::useFiles('${1:path}', '${2:level}');$3"
    ],
    "description": "Register a file log handler."
  },
  "Log-warning.sublime-snippet": {
    "prefix": "Log::warning",
    "body": [
      "Log::warning('${1:message}');$2"
    ],
    "description": "Log a warning message to the logs."
  },
  "Mail-later.sublime-snippet": {
    "prefix": "Mail::later",
    "body": [
      "Mail::later(${1:5}, '${2:Html.view}', ${3:\\$data}, function (${4:\\$message}) {",
      "    ${4}->from(${5:'john@johndoe.com'}, ${6:'John Doe'});",
      "    ${4}->sender(${7:'john@johndoe.com'}, ${8:'John Doe'});",
      "    ${4}->to(${9:'john@johndoe.com'}, ${10:'John Doe'});",
      "    ${4}->cc(${11:'john@johndoe.com'}, ${12:'John Doe'});",
      "    ${4}->bcc(${13:'john@johndoe.com'}, ${14:'John Doe'});",
      "    ${4}->replyTo(${15:'john@johndoe.com'}, ${16:'John Doe'});",
      "    ${4}->subject(${17:'Subject'});",
      "    ${4}->priority(${18:3});",
      "    ${4}->attach(${19:'pathToFile'});",
      "});$20"
    ],
    "description": "Queue a new e-mail message for sending after (n) seconds."
  },
  "Mail-laterOn.sublime-snippet": {
    "prefix": "Mail::laterOn",
    "body": [
      "Mail::queueOn(${1:'queue-name'}, ${2:5}, '${3:Html.view}', ${4:\\$data}, function (${5:\\$message}) {",
      "    ${5}->from(${6:'john@johndoe.com'}, ${7:'John Doe'});",
      "    ${5}->sender(${8:'john@johndoe.com'}, ${9:'John Doe'});",
      "    ${5}->to(${10:'john@johndoe.com'}, ${11:'John Doe'});",
      "    ${5}->cc(${12:'john@johndoe.com'}, ${13:'John Doe'});",
      "    ${5}->bcc(${14:'john@johndoe.com'}, ${15:'John Doe'});",
      "    ${5}->replyTo(${16:'john@johndoe.com'}, ${17:'John Doe'});",
      "    ${5}->subject(${18:'Subject'});",
      "    ${5}->priority(${19:3});",
      "    ${5}->attach(${20:'pathToFile'});",
      "});$21"
    ],
    "description": "Queue a new e-mail message for sending after (n) seconds on the given queue."
  },
  "Mail-plain.sublime-snippet": {
    "prefix": "Mail::plain",
    "body": [
      "Mail::plain('${1:plainText.view}', ${2:\\$data}, function (${3:\\$message}) {",
      "    ${3}->from(${4:'john@johndoe.com'}, ${5:'John Doe'});",
      "    ${3}->sender(${6:'john@johndoe.com'}, ${7:'John Doe'});",
      "    ${3}->to(${8:'john@johndoe.com'}, ${9:'John Doe'});",
      "    ${3}->cc(${10:'john@johndoe.com'}, ${11:'John Doe'});",
      "    ${3}->bcc(${12:'john@johndoe.com'}, ${13:'John Doe'});",
      "    ${3}->replyTo(${14:'john@johndoe.com'}, ${15:'John Doe'});",
      "    ${3}->subject(${16:'Subject'});",
      "    ${3}->priority(${17:3});",
      "    ${3}->attach(${18:'pathToFile'});",
      "});$19"
    ],
    "description": "Send a new message when only a plain part."
  },
  "Mail-queue.sublime-snippet": {
    "prefix": "Mail::queue",
    "body": [
      "Mail::queue('${1:Html.view}', ${2:\\$data}, function (${3:\\$message}) {",
      "    ${3}->from(${4:'john@johndoe.com'}, ${5:'John Doe'});",
      "    ${3}->sender(${6:'john@johndoe.com'}, ${7:'John Doe'});",
      "    ${3}->to(${8:'john@johndoe.com'}, ${9:'John Doe'});",
      "    ${3}->cc(${10:'john@johndoe.com'}, ${11:'John Doe'});",
      "    ${3}->bcc(${12:'john@johndoe.com'}, ${13:'John Doe'});",
      "    ${3}->replyTo(${14:'john@johndoe.com'}, ${15:'John Doe'});",
      "    ${3}->subject(${16:'Subject'});",
      "    ${3}->priority(${17:3});",
      "    ${3}->attach(${18:'pathToFile'});",
      "});$19"
    ],
    "description": "Queue a new e-mail message for sending."
  },
  "Mail-queueOn.sublime-snippet": {
    "prefix": "Mail::queueOn",
    "body": [
      "Mail::queueOn(${1:'queue-name'}, '${2:Html.view}', ${3:\\$data}, function (${4:\\$message}) {",
      "    ${4}->from(${5:'john@johndoe.com'}, ${6:'John Doe'});",
      "    ${4}->sender(${7:'john@johndoe.com'}, ${8:'John Doe'});",
      "    ${4}->to(${9:'john@johndoe.com'}, ${10:'John Doe'});",
      "    ${4}->cc(${11:'john@johndoe.com'}, ${12:'John Doe'});",
      "    ${4}->bcc(${13:'john@johndoe.com'}, ${14:'John Doe'});",
      "    ${4}->replyTo(${15:'john@johndoe.com'}, ${16:'John Doe'});",
      "    ${4}->subject(${17:'Subject'});",
      "    ${4}->priority(${18:3});",
      "    ${4}->attach(${19:'pathToFile'});",
      "});$20"
    ],
    "description": "Queue a new e-mail message for sending on the given queue."
  },
  "Mail-raw.sublime-snippet": {
    "prefix": "Mail::raw",
    "body": [
      "Mail::raw('${1:plain text message}', function (${2:\\$message}) {",
      "    ${2}->from(${3:'john@johndoe.com'}, ${4:'John Doe'});",
      "    ${2}->sender(${5:'john@johndoe.com'}, ${6:'John Doe'});",
      "    ${2}->to(${7:'john@johndoe.com'}, ${8:'John Doe'});",
      "    ${2}->cc(${9:'john@johndoe.com'}, ${10:'John Doe'});",
      "    ${2}->bcc(${11:'john@johndoe.com'}, ${12:'John Doe'});",
      "    ${2}->replyTo(${13:'john@johndoe.com'}, ${14:'John Doe'});",
      "    ${2}->subject(${15:'Subject'});",
      "    ${2}->priority(${16:3});",
      "    ${2}->attach(${17:'pathToFile'});",
      "});$18"
    ],
    "description": "Send a new message when only a raw text part."
  },
  "Mail-send.sublime-snippet": {
    "prefix": "Mail::send",
    "body": [
      "Mail::send('${1:Html.view}', ${2:\\$data}, function (${3:\\$message}) {",
      "    ${3}->from(${4:'john@johndoe.com'}, ${5:'John Doe'});",
      "    ${3}->sender(${6:'john@johndoe.com'}, ${7:'John Doe'});",
      "    ${3}->to(${8:'john@johndoe.com'}, ${9:'John Doe'});",
      "    ${3}->cc(${10:'john@johndoe.com'}, ${11:'John Doe'});",
      "    ${3}->bcc(${12:'john@johndoe.com'}, ${13:'John Doe'});",
      "    ${3}->replyTo(${14:'john@johndoe.com'}, ${15:'John Doe'});",
      "    ${3}->subject(${16:'Subject'});",
      "    ${3}->priority(${17:3});",
      "    ${3}->attach(${18:'pathToFile'});",
      "});$19"
    ],
    "description": "Send a new message using a view."
  },
  "Mail-to": {
    "prefix": "Mail::to",
    "body": [
      "Mail::to(${1:\\$request->user()})->send(new ${2:MailableClass});$3"
    ],
    "description": "Mail with Mailable - mailer will automatically use collection 'email' and 'name' properties"
  },
  "Mail-to-more": {
    "prefix": "Mail::to-more",
    "body": [
      "Mail::to(${1:\\$request->user()})",
      "    ->cc(${2:\\$moreUsers})",
      "    ->bcc(${3:\\$evenMoreUsers})",
      "    ->send(new ${4:MailableClass});$5"
    ],
    "description": "Mail with Mailable - mail to more recipients"
  },
  "Mail-queue-mailable": {
    "prefix": "Mail::queue-mailable",
    "body": [
      "Mail::to(${1:\\$request->user()})",
      "    ->cc(${2:\\$moreUsers})",
      "    ->bcc(${3:\\$evenMoreUsers})",
      "    ->queue(new ${4:MailableClass});$5"
    ],
    "description": "Mail with Mailable - Queueing A Mail Message"
  },
  "Mail-later-mailable": {
    "prefix": "Mail::later-mailable",
    "body": [
      "Mail::to(${1:\\$request->user()})",
      "    ->cc(${2:\\$moreUsers})",
      "    ->bcc(${3:\\$evenMoreUsers})",
      "    ->later(${4:\\$when}, new ${5:MailableClass});$6"
    ],
    "description": "Mail with Mailable - Delayed Message Queueing"
  },
  "Mailable-build-config": {
    "prefix": "Mailable::build-config",
    "body": [
      "return $this->from('${1:example@example.com}')",
      "    ->${2:view}('${3:mails.viewName}')",
      "    ->with([",
      "            ${4:'orderName' => $this->order->name,}",
      "     ]);$5"
    ],
    "description": "Mailable - Configuring Mailable build()"
  },
  "Passport-routes": {
    "prefix": "Passport::routes",
    "body": [
      "Passport::routes();"
    ],
    "description": "Passport - routes"
  },
  "Passport-tokensExpireIn": {
    "prefix": "Passport::tokensExpireIn",
    "body": [
      "Passport::tokensExpireIn(Carbon::now()->addDays(${1:15}));$2"
    ],
    "description": "Passport - tokensExpireIn"
  },
  "Passport-refreshTokensExpireIn": {
    "prefix": "Passport::refreshTokensExpireIn",
    "body": [
      "Passport::refreshTokensExpireIn(Carbon::now()->addDays(${1:30}));$2"
    ],
    "description": "Passport - refreshTokensExpireIn"
  },
  "Passport-pruneRevokedTokens": {
    "prefix": "Passport::pruneRevokedTokens",
    "body": [
      "Passport::pruneRevokedTokens();"
    ],
    "description": "Passport - pruneRevokedTokens"
  },
  "Redirect-action.sublime-snippet": {
    "prefix": "Redirect::action",
    "body": [
      "return redirect()->action('${App\\Http\\Controllers\\HomeController@index}', ${2:['parameterKey' => 'value']});$3"
    ],
    "description": "Redirect to a controller action, with parameters"
  },
  "Redirect-back.sublime-snippet": {
    "prefix": "Redirect::back",
    "body": [
      "return redirect()->back()${1:->withErrors(\\$validator)}${2:->withInput()};$3"
    ],
    "description": "Redirect to URL, Route or Controller"
  },
  "Redirect-namedRoute.sublime-snippet": {
    "prefix": "Redirect::namedRoute",
    "body": [
      "return redirect()->route('${named_route}', ${2:['parameterKey' => 'value']});$3"
    ],
    "description": "Redirect to a named route, with parameters"
  },
  "Redirect-to.sublime-snippet": {
    "prefix": "Redirect::to",
    "body": [
      "return redirect('${1:some/url}');$2"
    ],
    "description": "Redirect to URL, Route or Controller"
  },
  "Redirect-withErrors.sublime-snippet": {
    "prefix": "Redirect::withErrors",
    "body": [
      "->withErrors(${1:\\$validator})$2"
    ],
    "description": "Redirect to URL, Route or Controller with Errors"
  },
  "Redirect-withFlashData.sublime-snippet": {
    "prefix": "Redirect::withFlashData",
    "body": [
      "->with('${1:flashKey}', '${2:flashValue}')$3"
    ],
    "description": "Redirect to URL, Route or Controller with Flash Data"
  },
  "Redirect-withInput.sublime-snippet": {
    "prefix": "Redirect::withInput",
    "body": [
      "->withInput(${1:[1, 2])})$2"
    ],
    "description": "Redirect to URL, Route or Controller with Input"
  },
  "Redirect-withInputAndErrors.sublime-snippet": {
    "prefix": "Redirect::withInputAndErrors",
    "body": [
      "->withInput(${1:\\$request->except('key')})",
      "->withErrors(${2:\\$validator})$3"
    ],
    "description": "Redirect with Inputs and Errors"
  },
  "Redirect-withNamedInput.sublime-snippet": {
    "prefix": "Redirect::withNamedInput",
    "body": [
      "->withInput(${1:['key' => 'value'])})$2"
    ],
    "description": "Redirect to URL, Route or Controller with Input"
  },
  "Relation-belongsTo.sublime-snippet": {
    "prefix": "Relation::belongsTo",
    "body": [
      "public function ${1:user}()",
      "{",
      "    return \\$this->belongsTo('${2:App\\User}'${3:, '${4:foreign_key}'}${5:, '${6:other_key}'});",
      "}$7"
    ],
    "description": "A one-to-one inverse relationship."
  },
  "Relation-belongsToMany.sublime-snippet": {
    "prefix": "Relation::belongsToMany",
    "body": [
      "public function ${1:roles}()",
      "{",
      "    return \\$this->belongsToMany('${2:App\\Role}'${3:, '${4:role_user_table}'}${5:, '${6:user_id}'}${7:, '${8:role_id}'});",
      "}$9"
    ],
    "description": "A many-to-many relationship."
  },
  "Relation-hasMany.sublime-snippet": {
    "prefix": "Relation::hasMany",
    "body": [
      "public function ${1:comments}()",
      "{",
      "    return \\$this->hasMany('${2:App\\Comment}'${3:, '${4:foreign_key}'}${5:, '${6:local_key}'});",
      "}$7"
    ],
    "description": "A one-to-many relationship."
  },
  "Relation-hasManyThrough.sublime-snippet": {
    "prefix": "Relation::hasManyThrough",
    "body": [
      "public function ${1:comments}()",
      "{",
      "    return \\$this->hasManyThrough('${2:App\\Comment}', ${3:App\\Post});",
      "}$4"
    ],
    "description": "A Has Many Through relationship."
  },
  "Relation-hasOne.sublime-snippet": {
    "prefix": "Relation::hasOne",
    "body": [
      "public function ${1:user}()",
      "{",
      "    return \\$this->hasOne('${2:App\\User}'${3:, '${4:foreign_key}'}${5:, '${6:local_key}'});",
      "}$7"
    ],
    "description": "A one-to-one relationship."
  },
  "Request-method.sublime-snippet": {
    "prefix": "Request::method",
    "body": [
      "\\$request->method()"
    ],
    "description": "Get the request method (GET, POST, ...)."
  },
  "Request-root.sublime-snippet": {
    "prefix": "Request::root",
    "body": [
      "\\$request->root()"
    ],
    "description": "Get the root URL for the application."
  },
  "Request-url.sublime-snippet": {
    "prefix": "Request::url",
    "body": [
      "\\$request->url()"
    ],
    "description": "Get the URL (no query string) for the request."
  },
  "Request-fullUrl.sublime-snippet": {
    "prefix": "Request::fullUrl",
    "body": [
      "\\$request->fullUrl()"
    ],
    "description": "Get the full URL for the request."
  },
  "Request-fullUrlWithQuery": {
    "prefix": "Request::fullUrlWithQuery",
    "body": [
      "\\$request->fullUrlWithQuery(${1:\\$query})$2"
    ],
    "description": "Get the full URL for the request with the added query string parameters."
  },
  "Request-path.sublime-snippet": {
    "prefix": "Request::path",
    "body": [
      "\\$request->path()"
    ],
    "description": "Get the current path info for the request."
  },
  "Request-decodedPath.sublime-snippet": {
    "prefix": "Request::decodedPath",
    "body": [
      "\\$request->decodedPath()"
    ],
    "description": "Get the current encoded path info for the request."
  },
  "Request-segment.sublime-snippet": {
    "prefix": "Request::segment",
    "body": [
      "\\$request->segment(${1:\\$index}, '${2:default}')$3"
    ],
    "description": "Get a segment from the URI (1 based index)."
  },
  "Request-segments.sublime-snippet": {
    "prefix": "Request::segments",
    "body": [
      "\\$request->segments()"
    ],
    "description": "Get all of the segments for the request path."
  },
  "Request-is": {
    "prefix": "Request::is",
    "body": [
      "\\$request->is()"
    ],
    "description": "Determine if the current request URI matches a pattern."
  },
  "Request-fullUrlIs": {
    "prefix": "Request::fullUrlIs",
    "body": [
      "\\$request->fullUrlIs()"
    ],
    "description": "Determine if the current request URL and query string matches a pattern."
  },
  "Request-ajax.sublime-snippet": {
    "prefix": "Request::ajax",
    "body": [
      "\\$request->ajax()"
    ],
    "description": "Determine if the request is the result of an AJAX call."
  },
  "Request-pjax.sublime-snippet": {
    "prefix": "Request::pjax",
    "body": [
      "\\$request->pjax()"
    ],
    "description": "Determine if the request is the result of an PJAX call."
  },
  "Request-secure.sublime-snippet": {
    "prefix": "Request::secure",
    "body": [
      "\\$request->secure()"
    ],
    "description": "Determine if the request is over HTTPS."
  },
  "Request-ip.sublime-snippet": {
    "prefix": "Request::ip",
    "body": [
      "\\$request->ip()"
    ],
    "description": "Returns the client IP address."
  },
  "Request-ips.sublime-snippet": {
    "prefix": "Request::ips",
    "body": [
      "\\$request->ips()"
    ],
    "description": "Returns the client IP addresses."
  },
  "Request-exists.sublime-snippet": {
    "prefix": "Request::exists",
    "body": [
      "\\$request->exists('${1:key}')$2"
    ],
    "description": "Determine if the request contains a given input item key."
  },
  "Request-has.sublime-snippet": {
    "prefix": "Request::has",
    "body": [
      "\\$request->has('${1:key}')$2"
    ],
    "description": "Determine if the request contains a non-empty value for an input item."
  },
  "Request-all.sublime-snippet": {
    "prefix": "Request::all",
    "body": [
      "\\$request->all()"
    ],
    "description": "Get all of the input and files for the request."
  },
  "Request-input.sublime-snippet": {
    "prefix": "Request::input",
    "body": [
      "\\$request->input('${1:key}'${2:, 'default'})$3"
    ],
    "description": "Retrieve an input item from the request."
  },
  "Request-only.sublime-snippet": {
    "prefix": "Request::only",
    "body": [
      "\\$request->only(${1:\\$keys})$2"
    ],
    "description": "Get a subset of the items from the input data."
  },
  "Request-except.sublime-snippet": {
    "prefix": "Request::except",
    "body": [
      "\\$request->except(${1:\\$keys})$2"
    ],
    "description": "Get all of the input except for a specified array of items."
  },
  "Request-intersect": {
    "prefix": "Request::intersect",
    "body": [
      "\\$request->intersect(${1:\\$keys})$2"
    ],
    "description": "Intersect an array of items with the input data."
  },
  "Request-query.sublime-snippet": {
    "prefix": "Request::query",
    "body": [
      "\\$request->query('${1:key}', '${2:default'})$3"
    ],
    "description": "Retrieve a query string item from the request."
  },
  "Request-hasCookie": {
    "prefix": "Request::hasCookie",
    "body": [
      "\\$request->hasCookie('${1:key}')$2"
    ],
    "description": "Determine if a cookie is set on the request."
  },
  "Request-cookie": {
    "prefix": "Request::cookie",
    "body": [
      "\\$request->cookie('${1:key}', '${2:default'})$3"
    ],
    "description": "Retrieve a cookie from the request."
  },
  "Request-allFiles.sublime-snippet": {
    "prefix": "Request::allFiles",
    "body": [
      "\\$request->allFiles()"
    ],
    "description": "Get an array of all of the files on the request."
  },
  "Request-file.sublime-snippet": {
    "prefix": "Request::file",
    "body": [
      "\\$request->file('${1:key}'${2:, 'default'})$2"
    ],
    "description": "Retrieve a file from the request."
  },
  "Request-hasFile.sublime-snippet": {
    "prefix": "Request::hasFile",
    "body": [
      "\\$request->hasFile('${1:key}')$2"
    ],
    "description": "Determine if the uploaded data contains a file."
  },
  "Request-hasHeader": {
    "prefix": "Request::hasHeader",
    "body": [
      "\\$request->hasHeader('${1:key}')$2"
    ],
    "description": "Determine if a header is set on the request."
  },
  "Request-header.sublime-snippet": {
    "prefix": "Request::header",
    "body": [
      "\\$request->header('${1:key}', ${2:\\$default})$3"
    ],
    "description": "Retrieve a header from the request."
  },
  "Request-server": {
    "prefix": "Request::server",
    "body": [
      "\\$request->server('${1:key}', ${2:\\$default})$3"
    ],
    "description": "Retrieve a server variable from the request."
  },
  "Request-old.sublime-snippet": {
    "prefix": "Request::old",
    "body": [
      "\\$request->old('${1:key}'${2:, 'default'})$3"
    ],
    "description": "Retrieve an old input item."
  },
  "Input-flash.sublime-snippet": {
    "prefix": "Request::flash",
    "body": [
      "\\$request->flash();"
    ],
    "description": "Flash Input to the Session"
  },
  "Input-flashOnly.sublime-snippet": {
    "prefix": "Request::flashOnly",
    "body": [
      "\\$request->flashOnly(${1:\\$keys});$2"
    ],
    "description": "Flash only some Input to the Session"
  },
  "Input-flashExcept.sublime-snippet": {
    "prefix": "Request::flashExcept",
    "body": [
      "\\$request->flashExcept(${1:\\$keys});$2"
    ],
    "description": "Flash only some Input to the Session"
  },
  "Request-flush": {
    "prefix": "Request::flush",
    "body": [
      "\\$request->flush();"
    ],
    "description": "Flush all of the old input from the session."
  },
  "Request-merge": {
    "prefix": "Request::merge",
    "body": [
      "\\$request->merge(${1:\\$input})$2"
    ],
    "description": "Merge new input into the current request's input array."
  },
  "Request-replace": {
    "prefix": "Request::replace",
    "body": [
      "\\$request->replace(${1:\\$input})$2"
    ],
    "description": "Replace the input for the current request."
  },
  "Request-json.sublime-snippet": {
    "prefix": "Request::json",
    "body": [
      "\\$request->json()"
    ],
    "description": "Determine if the request is sending JSON."
  },
  "Request-isJson": {
    "prefix": "Request::isJson",
    "body": [
      "\\$request->isJson()"
    ],
    "description": "Determine if the request is sending JSON."
  },
  "Request-wantsJson": {
    "prefix": "Request::wantsJson",
    "body": [
      "\\$request->wantsJson()"
    ],
    "description": "Determine if the current request is asking for JSON in return."
  },
  "Request-accepts": {
    "prefix": "Request::accepts",
    "body": [
      "\\$request->accepts(${1:\\$contentTypes})$2"
    ],
    "description": "Determines whether the current requests accepts a given content type."
  },
  "Request-prefers": {
    "prefix": "Request::prefers",
    "body": [
      "\\$request->prefers(${1:\\$contentTypes})$2"
    ],
    "description": "Return the most suitable content type from the given array based on content negotiation."
  },
  "Request-acceptsJson": {
    "prefix": "Request::acceptsJson",
    "body": [
      "\\$request->acceptsJson()"
    ],
    "description": "Determines whether a request accepts JSON."
  },
  "Request-acceptsHtml": {
    "prefix": "Request::acceptsHtml",
    "body": [
      "\\$request->acceptsHtml()"
    ],
    "description": "Determines whether a request accepts HTML."
  },
  "Request-format": {
    "prefix": "Request::format",
    "body": [
      "\\$request->format('${1:html}')$2"
    ],
    "description": "Get the data format expected in the response."
  },
  "Request-bearerToken": {
    "prefix": "Request::bearerToken",
    "body": [
      "\\$request->bearerToken()"
    ],
    "description": "Get the bearer token from the request headers."
  },
  "Request-session.sublime-snippet": {
    "prefix": "Request::session",
    "body": [
      "\\$request->session()"
    ],
    "description": "Get the session associated with the request."
  },
  "Request-user.sublime-snippet": {
    "prefix": "Request::user",
    "body": [
      "\\$request->user()"
    ],
    "description": "Get the user making the request."
  },
  "Request-route": {
    "prefix": "Request::route",
    "body": [
      "\\$request->route(${1:\\$param})"
    ],
    "description": "Get the route handling the request."
  },
  "Request-fingerprint.sublime-snippet": {
    "prefix": "Request::fingerprint",
    "body": [
      "\\$request->fingerprint()"
    ],
    "description": "Get a unique fingerprint for the request / route / IP address."
  },
  "Request-getUserResolver": {
    "prefix": "Request::getUserResolver",
    "body": [
      "\\$request->getUserResolver()"
    ],
    "description": "Get the user resolver callback."
  },
  "Request-setUserResolver": {
    "prefix": "Request::setUserResolver",
    "body": [
      "\\$request->setUserResolver(${1:\\$callback})$2"
    ],
    "description": "Set the user resolver callback."
  },
  "Request-getRouteResolver": {
    "prefix": "Request::getRouteResolver",
    "body": [
      "\\$request->getRouteResolver()"
    ],
    "description": "Get the route resolver callback."
  },
  "Request-setRouteResolver": {
    "prefix": "Request::setRouteResolver",
    "body": [
      "\\$request->setRouteResolver(${1:\\$callback})$2"
    ],
    "description": "Set the route resolver callback."
  },
  "Request-toArray": {
    "prefix": "Request::toArray",
    "body": [
      "\\$request->toArray()"
    ],
    "description": "Get all of the input and files for the request."
  },
  "Request-offsetExists": {
    "prefix": "Request::offsetExists",
    "body": [
      "\\$request->offsetExists('${1:offset}')$2"
    ],
    "description": "Determine if the given offset exists."
  },
  "Request-offsetSet": {
    "prefix": "Request::offsetSet",
    "body": [
      "\\$request->offsetSet('${1:offset}', ${2:\\$value});$3"
    ],
    "description": "Set the value at the given offset."
  },
  "Request-offsetUnset": {
    "prefix": "Request::offsetUnset",
    "body": [
      "\\$request->offsetUnset('${1:offset}');$2"
    ],
    "description": "Remove the value at the given offset."
  },
  "Response-download.sublime-snippet": {
    "prefix": "Response::download",
    "body": [
      "return response()->download(${1:\\$pathToFile}, ${2:\\$name}, ${3:\\$headers});"
    ],
    "description": "Create a File Download Response"
  },
  "Response-json.sublime-snippet": {
    "prefix": "Response::json",
    "body": [
      "return response()->json(${1:\\$data}, ${2:200}, ${3:\\$headers});"
    ],
    "description": "Create a JSON Response"
  },
  "Response-JSONP.sublime-snippet": {
    "prefix": "Response::jsonp",
    "body": [
      "return response()->jsonp(${1:\\$callback}, ${2:\\$data}, ${3:200}, ${4:\\$headers});"
    ],
    "description": "Create a JSONP Response"
  },
  "Response-make.sublime-snippet": {
    "prefix": "Response::make",
    "body": [
      "return Response::make(${1:\\$contents}, ${2:200}, ${3:\\$headers});"
    ],
    "description": "Create a Custom Response"
  },
  "Route-any.sublime-snippet": {
    "prefix": "Route::any",
    "body": [
      "Route::any('${2:users/{id\\}}', function (${3:\\$id}) {",
      "    $4",
      "});"
    ],
    "description": "Basic Route with Closure."
  },
  "Route-closure.sublime-snippet": {
    "prefix": "Route::closure",
    "body": [
      "Route::${1:get}('${2:users/{id\\}}', function (${3:\\$id}) {",
      "    $4",
      "});"
    ],
    "description": "Basic Route with Closure."
  },
  "Route-controller.sublime-snippet": {
    "prefix": "Route::controller",
    "body": [
      "Route::controller('${1:users}', '${2:UserController}');"
    ],
    "description": "Route a controller to a URI with wildcard routing."
  },
  "Route-controllerAction.sublime-snippet": {
    "prefix": "Route::controllerAction",
    "body": [
      "Route::${1:get}('${2:users/{id\\}}', '${3:$UserController@profile}');"
    ],
    "description": "Basic route to a controller action."
  },
  "Route-currentRouteAction.sublime-snippet": {
    "prefix": "Route::currentRouteAction",
    "body": [
      "Route::currentRouteAction();"
    ],
    "description": "Get the current route name."
  },
  "Route-delete.sublime-snippet": {
    "prefix": "Route::delete",
    "body": [
      "Route::delete('${1:users/{id\\}}', function (${2:\\$id}) {",
      "    $3",
      "});"
    ],
    "description": "Basic Delete Route."
  },
  "Route-get.sublime-snippet": {
    "prefix": "Route::get",
    "body": [
      "Route::get('${1:users/{id\\}}', function (${2:\\$id}) {",
      "    $3",
      "});"
    ],
    "description": "Basic Get Route."
  },
  "Router-post.sublime-snippet": {
    "prefix": "Route::post",
    "body": [
      "Route::post('${1:users/{id\\}}', function (${2:\\$id}) {",
      "    $3",
      "});"
    ],
    "description": "Basic Post Route."
  },
  "Route-group.sublime-snippet": {
    "prefix": "Route::group",
    "body": [
      "Route::group(${1:['${2:prefix}' => '${3:admin}']}, function () {",
      "    $4",
      "});"
    ],
    "description": "Create a Group of Routes"
  },
  "Route-group-middleware": {
    "prefix": "Route::group-middleware",
    "body": [
      "Route::group(['middleware' => ['${1:groupName}']], function () {",
      "    $2",
      "});"
    ],
    "description": "Create a Group of Routers with middleware defined in RouteServiceProvider"
  },
  "Route-match.sublime-snippet": {
    "prefix": "Route::match",
    "body": [
      "Route::match([${1:'get', 'post'}], '${2:/user/profile}', function () {",
      "    $3",
      "});"
    ],
    "description": "Register a new route with the given verbs."
  },
  "Route-put.sublime-snippet": {
    "prefix": "Route::put",
    "body": [
      "Route::put('${1:users/{id\\}}', function (${2:\\$id}) {",
      "    $3",
      "});"
    ],
    "description": "Basic Put Route."
  },
  "Route-resource.sublime-snippet": {
    "prefix": "Route::resource",
    "body": [
      "Route::resource('${1:user}', '${2:UserController}');"
    ],
    "description": "Route to a RESTful Controller"
  },
  "Route-when.sublime-snippet": {
    "prefix": "Route::when",
    "body": [
      "\\$router->when('${1:admin/*}', '${2:admin}', ${3:['post']})$4"
    ],
    "description": "Pattern based filters on routes"
  },
  "Router-model.sublime-snippet": {
    "prefix": "Route::model",
    "body": [
      "\\$router->model('${1:user}', '${2:App\\User}')$3"
    ],
    "description": "Register a model binder for a wildcard."
  },
  "Router-pattern.sublime-snippet": {
    "prefix": "Route::pattern",
    "body": [
      "\\$router->pattern('${1:id}', '${2:[0-9]+}')$3"
    ],
    "description": "Set a global where pattern on all routes."
  },
  "Route-redirect": {
    "prefix": "Route::redirect",
    "body": "Route::redirect('${1:URI}', '${2:URI}', ${3:301});",
    "description": "a convenient shortcut for performing a simple redirect"
  },
  "Route-view": {
    "prefix": "Route::view",
    "body": "Route::view('${1:URI}', '${2:viewName}');",
    "description": "route only needs to return a view; you may provide an array of data to pass to the view as an optional third argument"
  },
  "Schema-connection.sublime-snippet": {
    "prefix": "Schema::connection",
    "body": [
      "Schema::connection('${1:foo}')->create('${2:users}', function (${3:\\$table}) {",
      "    \\$table->bigIncrements('id');$0",
      "});"
    ],
    "description": "Specify connection for schema operation"
  },
  "Schema-create-table.sublime-snippet": {
    "prefix": "Schema::create-table",
    "body": [
      "Schema::create('${1:users}', function (Blueprint \\$table) {",
      "    \\$table->bigIncrements('id');",
      "    $0",
      "    \\$table->timestamps();",
      "});"
    ],
    "description": "Create new table"
  },
  "Schema-drop.sublime-snippet": {
    "prefix": "Schema::drop",
    "body": [
      "Schema::drop('${1:table}');$0"
    ],
    "description": "Drop an existing database table"
  },
  "Schema-dropIfExists.sublime-snippet": {
    "prefix": "Schema::dropIfExists",
    "body": [
      "Schema::dropIfExists('${1:table}');$0"
    ],
    "description": "Drop an existing database table if it exists"
  },
  "Schema-hasColumn.sublime-snippet": {
    "prefix": "Schema::hasColumn",
    "body": [
      "if (Schema::hasColumn('${1:table}', '${2:column}')) {",
      "    $0",
      "}"
    ],
    "description": "Check for existence of column(s)"
  },
  "Schema-hasTable.sublime-snippet": {
    "prefix": "Schema::hasTable",
    "body": [
      "if (Schema::hasTable('${1:table}')) {",
      "    $0",
      "}"
    ],
    "description": "Check for existence of table"
  },
  "Schema-rename-table.sublime-snippet": {
    "prefix": "Schema::rename-table",
    "body": [
      "Schema::rename(${1:\\$from}, ${2:\\$to});$0"
    ],
    "description": "Rename an existing database table"
  },
  "Schema-table-update.sublime-snippet": {
    "prefix": "Schema::table-update",
    "body": [
      "Schema::table('${1:users}', function (Blueprint \\$table) {",
      "    $0",
      "});"
    ],
    "description": "Update an existing table"
  },
  "table-bigIncrements.sublime-snippet": {
    "prefix": "Column::bigIncrements",
    "body": [
      "\\$table->bigIncrements('${1:id}');$2"
    ],
    "description": "Incrementing ID using a \"big integer\" equivalent."
  },
  "table-bigInteger.sublime-snippet": {
    "prefix": "Column::bigInteger",
    "body": [
      "\\$table->bigInteger('${1:votes}')${2:->nullable()}${3:->default(${4:12})};$0"
    ],
    "description": "BIGINT equivalent to the table"
  },
  "table-binary.sublime-snippet": {
    "prefix": "Column::binary",
    "body": [
      "\\$table->binary('${1:data}')${2:->nullable()}${3:->default(${4:12})};$0"
    ],
    "description": "BLOB equivalent to the table"
  },
  "table-boolean.sublime-snippet": {
    "prefix": "Column::boolean",
    "body": [
      "\\$table->boolean('${1:confirmed}')${2:->nullable()}${3:->default(${4:false})};$0"
    ],
    "description": "BOOLEAN equivalent to the table"
  },
  "table-char.sublime-snippet": {
    "prefix": "Column::char",
    "body": [
      "\\$table->char('${1:name}', ${2:4})${2:->nullable()}${3:->default(${4:'text'})};$0"
    ],
    "description": "CHAR equivalent with a length (optional)"
  },
  "table-date.sublime-snippet": {
    "prefix": "Column::date",
    "body": [
      "\\$table->date('${1:created_at}')${2:->nullable()}${3:->default(${4:new DateTime()})};$0"
    ],
    "description": "DATE equivalent to the table"
  },
  "table-dateTime.sublime-snippet": {
    "prefix": "Column::dateTime",
    "body": [
      "\\$table->dateTime('${1:created_at}')${2:->nullable()}${3:->default(${4:new DateTime()})};$0"
    ],
    "description": "DATETIME equivalent to the table"
  },
  "table-decimal.sublime-snippet": {
    "prefix": "Column::decimal",
    "body": [
      "\\$table->double('${1:amount}', ${2:5}, ${3:2})${4:->nullable()}${5:->default(${6:123.45})};$0"
    ],
    "description": "DECIMAL equivalent with a precision and scale"
  },
  "table-double.sublime-snippet": {
    "prefix": "Column::double",
    "body": [
      "\\$table->double('${1:column}', ${2:15}, ${3:8})${4:->nullable()}${5:->default(${6:123.4567})};$0"
    ],
    "description": "DOUBLE equivalent with precision"
  },
  "table-dropColumn.sublime-snippet": {
    "prefix": "Column::dropColumn",
    "body": [
      "\\$table->dropColumn('${1:column}');$0"
    ],
    "description": "Drop a column"
  },
  "table-dropForeign.sublime-snippet": {
    "prefix": "Column::dropForeign",
    "body": [
      "\\$table->dropForeign('${1:posts_user_id_foreign}');$0"
    ],
    "description": "Drop a Foreign Key"
  },
  "table-dropIndex.sublime-snippet": {
    "prefix": "Column::dropIndex",
    "body": [
      "\\$table->dropIndex('${1:geo_state_index}');$0"
    ],
    "description": "Drop a basic Index"
  },
  "table-dropPrimary.sublime-snippet": {
    "prefix": "Column::dropPrimary",
    "body": [
      "\\$table->dropPrimary('${1:users_id_primary}');$0"
    ],
    "description": "Drop a Primary key"
  },
  "table-dropUnique.sublime-snippet": {
    "prefix": "Column::dropUnique",
    "body": [
      "\\$table->dropUnique('${1:users_email_unique}');$0"
    ],
    "description": "Drop a Unique Index"
  },
  "table-engine.sublime-snippet": {
    "prefix": "Column::engine",
    "body": [
      "\\$table->engine = '${1:InnoDB}';$0"
    ],
    "description": "Set the storage engine for a table"
  },
  "table-enum.sublime-snippet": {
    "prefix": "Column::enum",
    "body": [
      "\\$table->enum('${1:choices}', ${2:['foo', 'bar']})${3:->nullable()}${4:->default(${5:['foo', 'bar']})};$0"
    ],
    "description": "ENUM equivalent to the table"
  },
  "table-float.sublime-snippet": {
    "prefix": "Column::float",
    "body": [
      "\\$table->float('${1:amount}')${2:->nullable()}${3:->default(${4:123.45})};$0"
    ],
    "description": "FLOAT equivalent to the table"
  },
  "table-increments.sublime-snippet": {
    "prefix": "Column::increments",
    "body": [
      "\\$table->increments('${1:id}');$0"
    ],
    "description": "Incrementing ID"
  },
  "table-index-foreign.sublime-snippet": {
    "prefix": "Column::index-foreign",
    "body": [
      "\\$table->foreign('${1:user_id}')->references('${2:id}')->on('${3:users}')${4:->onDelete('${5:cascade}')};$0"
    ],
    "description": "Add a Foreign Key to a table"
  },
  "table-index-index.sublime-snippet": {
    "prefix": "Column::index",
    "body": [
      "\\$table->index('${1:column}');$0"
    ],
    "description": "Adding a basic index"
  },
  "table-index-primary.sublime-snippet": {
    "prefix": "Column::index-primary",
    "body": [
      "\\$table->primary('${1:id}');$0"
    ],
    "description": "Add a primary or array of composite keys"
  },
  "table-index-unique.sublime-snippet": {
    "prefix": "Column::index-unique",
    "body": [
      "\\$table->unique('${1:column}');$0"
    ],
    "description": "Add a unique index"
  },
  "table-integer.sublime-snippet": {
    "prefix": "Column::integer",
    "body": [
      "\\$table->integer('${1:votes}')${2:->unsigned()}${3:->nullable()}${4:->default(${5:12})};$0"
    ],
    "description": "INTEGER equivalent to the table"
  },
  "table-json.sublime-snippet": {
    "prefix": "Column::json",
    "body": [
      "\\$table->json('${1:column}')${2:->nullable()};$0"
    ],
    "description": "JSON equivalent to the table"
  },
  "table-jsonb.sublime-snippet": {
    "prefix": "Column::jsonb",
    "body": [
      "\\$table->jsonb('${1:column}')${2:->nullable()};$0"
    ],
    "description": "JSON equivalent to the table"
  },
  "table-longText.sublime-snippet": {
    "prefix": "Column::longText",
    "body": [
      "\\$table->longText('${1:description}')${2:->nullable()}${3:->default(${4:'text'})};$0"
    ],
    "description": "LONGTEXT equivalent to the table"
  },
  "table-mediumText.sublime-snippet": {
    "prefix": "Column::mediumText",
    "body": [
      "\\$table->mediumText('${1:mediumText}')${2:->nullable()}${3:->default(${4:'text'})};$0"
    ],
    "description": "MEDIUMTEXT equivalent to the table"
  },
  "table-morphs.sublime-snippet": {
    "prefix": "Column::morphs",
    "body": [
      "\\$table->morphs('${1:taggable}');$0"
    ],
    "description": "Adds INTEGER taggable_id and STRING taggable_type"
  },
  "table-rememberToken.sublime-snippet": {
    "prefix": "Column::rememberToken",
    "body": [
      "\\$table->rememberToken();"
    ],
    "description": "Adds remember_token as VARCHAR(100) NULL"
  },
  "table-renameColumn.sublime-snippet": {
    "prefix": "Column::renameColumn",
    "body": [
      "\\$table->renameColumn('${1:from}', '${2:to}');$0"
    ],
    "description": "Rename a column"
  },
  "table-smallInteger.sublime-snippet": {
    "prefix": "Column::smallInteger",
    "body": [
      "\\$table->smallInteger('${1:votes}')${2:->nullable()}${3:->default(${4:12})};$0"
    ],
    "description": "SMALLINT equivalent to the table"
  },
  "table-softDeletes.sublime-snippet": {
    "prefix": "Column::softDeletes",
    "body": [
      "\\$table->softDeletes();"
    ],
    "description": "Adds deleted_at column for soft deletes"
  },
  "table-string.sublime-snippet": {
    "prefix": "Column::string",
    "body": [
      "\\$table->string('${1:name}', ${2:100})${3:->nullable()}${5:->default(${6:'text'})};$0"
    ],
    "description": "VARCHAR equivalent with a length (optional)"
  },
  "table-text.sublime-snippet": {
    "prefix": "Column::text",
    "body": [
      "\\$table->text('${1:description}')${2:->nullable()}${3:->default(${4:'text'})};$0"
    ],
    "description": "TEXT equivalent to the table"
  },
  "table-time.sublime-snippet": {
    "prefix": "Column::time",
    "body": [
      "\\$table->time('${1:sunrise}')${2:->nullable()}${3:->default(${4:new DateTime()})};$0"
    ],
    "description": "TIME equivalent to the table"
  },
  "table-timestamp.sublime-snippet": {
    "prefix": "Column::timestamp",
    "body": [
      "\\$table->timestamp('${1:added_on}')${2:->nullable()}${3:->default(${4:time()})};$0"
    ],
    "description": "TIMESTAMP equivalent to the table"
  },
  "table-timestamps.sublime-snippet": {
    "prefix": "Column::timestamps",
    "body": [
      "\\$table->timestamps();"
    ],
    "description": "Adds created_at and updated_at columns"
  },
  "table-tinyInteger.sublime-snippet": {
    "prefix": "Column::tinyInteger",
    "body": [
      "\\$table->tinyInteger('${1:numbers}');$0"
    ],
    "description": "TINYINT equivalent to the table"
  },
  "table-uuid.sublime-snippet": {
    "prefix": "Column::uuid",
    "body": [
      "\\$table->uuid('${1:id}')${2:->nullable()}${3:->default(${4:null})};$0"
    ],
    "description": "UUID equivalent to the table"
  },
  "Session-all.sublime-snippet": {
    "prefix": "Session::all",
    "body": [
      "\\$request->session()->all();"
    ],
    "description": "Retrieve All Data from the Session"
  },
  "Session-flash.sublime-snippet": {
    "prefix": "Session::flash",
    "body": [
      "\\$request->session()->flash('${1:key}', ${2:\\$value});$3"
    ],
    "description": "Flash an Item in the Session"
  },
  "Session-flush.sublime-snippet": {
    "prefix": "Session::flush",
    "body": [
      "\\$request->session()->flush();"
    ],
    "description": "Remove All Items from the Session"
  },
  "Session-forget.sublime-snippet": {
    "prefix": "Session::forget",
    "body": [
      "\\$request->session()->forget('${1:key}');$2"
    ],
    "description": "Remove an Item from the Session"
  },
  "Session-get.sublime-snippet": {
    "prefix": "Session::get",
    "body": [
      "\\$request->session()->get('${1:key}', '${2:default}');$3"
    ],
    "description": "Retrieve an Item from the Session or Default Value"
  },
  "Session-has.sublime-snippet": {
    "prefix": "Session::has",
    "body": [
      "\\$request->session()->has('${1:key}');$2"
    ],
    "description": "Determin if an Item Exists in the Session"
  },
  "Session-keep.sublime-snippet": {
    "prefix": "Session::keep",
    "body": [
      "\\$request->session()->keep(${1:['key', 'otherkey']});$2"
    ],
    "description": "Reflash Only a Subset of Flash Data"
  },
  "Session-push.sublime-snippet": {
    "prefix": "Session::push",
    "body": [
      "\\$request->session()->push('${1:key.subArray}', '${2:value}');$3"
    ],
    "description": "Push a Value onto an Array Session Value"
  },
  "Session-put.sublime-snippet": {
    "prefix": "Session::put",
    "body": [
      "\\$request->session()->put('${1:key}', ${2:\\$value});$3"
    ],
    "description": "Store an Item in the Session"
  },
  "Session-reflash.sublime-snippet": {
    "prefix": "Session::reflash",
    "body": [
      "\\$request->session()->reflash();"
    ],
    "description": "Reflash the Current Flash Data"
  },
  "Session-regenerate.sublime-snippet": {
    "prefix": "Session::regenerate",
    "body": [
      "\\$request->session()->regenerate();"
    ],
    "description": "Regenerate the Session ID"
  },
  "Storage-allDirectories.sublime-snippet": {
    "prefix": "Storage::allDirectories",
    "body": [
      "Storage::allDirectories(${1:directory});$2"
    ],
    "description": "Returns an array of all the directories within a given directory and all of its sub-directories"
  },
  "Storage-allFiles.sublime-snippet": {
    "prefix": "Storage::allFiles",
    "body": [
      "Storage::allFiles(${1:directory});$2"
    ],
    "description": "Returns an array of all of the files in a directory and it's sub-directories"
  },
  "Storage-append.sublime-snippet": {
    "prefix": "Storage::append",
    "body": [
      "Storage::append(${1:filePath}, ${2:Appended Text});$3"
    ],
    "description": "Insert content at the end of a file"
  },
  "Storage-cleanDirectory.sublime-snippet": {
    "prefix": "Storage::cleanDirectory",
    "body": [
      "Storage::cleanDirectory(${1:directory});$2"
    ],
    "description": "Empty the specified directory of all files and folders."
  },
  "Storage-copy.sublime-snippet": {
    "prefix": "Storage::copy",
    "body": [
      "Storage::copy(${1:path}, ${2:target});$3"
    ],
    "description": "Copy an existing file to another location on the disk"
  },
  "Storage-delete.sublime-snippet": {
    "prefix": "Storage::delete",
    "body": [
      "Storage::delete(${1:['file', 'otherFile']});$2"
    ],
    "description": "Remove one or multiple files from the disk"
  },
  "Storage-deleteDirectory.sublime-snippet": {
    "prefix": "Storage::deleteDirectory",
    "body": [
      "Storage::deleteDirectory(${1:directory});$2"
    ],
    "description": "May be used to remove a directory, including all of its files, from the disk"
  },
  "Storage-directories.sublime-snippet": {
    "prefix": "Storage::directories",
    "body": [
      "Storage::directories(${1:directory});$2"
    ],
    "description": "Returns an array of all the directories within a given directory"
  },
  "Storage-exists.sublime-snippet": {
    "prefix": "Storage::exists",
    "body": [
      "Storage::exists(${1:filePath});$2"
    ],
    "description": "Determine if a file exists."
  },
  "Storage-extension.sublime-snippet": {
    "prefix": "Storage::extension",
    "body": [
      "Storage::extension(${1:filePath});$2"
    ],
    "description": "Extract the file extension from a file path."
  },
  "Storage-files.sublime-snippet": {
    "prefix": "Storage::files",
    "body": [
      "Storage::files(${1:directory});$2"
    ],
    "description": "Returns an array of all of the files in a directory"
  },
  "Storage-get.sublime-snippet": {
    "prefix": "Storage::get",
    "body": [
      "Storage::get(${1:filePath});$2"
    ],
    "description": "Retrieve the contents of a given file"
  },
  "Storage-isDirectory.sublime-snippet": {
    "prefix": "Storage::isDirectory",
    "body": [
      "Storage::isDirectory(${1:directory});$2"
    ],
    "description": "Determine if the given path is a directory."
  },
  "Storage-isFile.sublime-snippet": {
    "prefix": "Storage::isFile",
    "body": [
      "Storage::isFile(${1:path});$2"
    ],
    "description": "Determine if the given path is a directory."
  },
  "Storage-isWritable.sublime-snippet": {
    "prefix": "Storage::iswritable",
    "body": [
      "Storage::isWritable(${1:path});$2"
    ],
    "description": "Determine if the given path is writable."
  },
  "Storage-lastModified.sublime-snippet": {
    "prefix": "Storage::lastModified",
    "body": [
      "Storage::lastModified(${1:filePath});$2"
    ],
    "description": "Returns the UNIX timestamp of the last time the file was modified"
  },
  "Storage-makeDirectory.sublime-snippet": {
    "prefix": "Storage::makeDirectory",
    "body": [
      "Storage::makeDirectory(${1:directory});$2"
    ],
    "description": "Will create the given directory, including any needed sub-directories"
  },
  "Storage-mimeType.sublime-snippet": {
    "prefix": "Storage::mimeType",
    "body": [
      "Storage::mimeType(${1:path});$2"
    ],
    "description": "Get the mime-type of a given file."
  },
  "Storage-move.sublime-snippet": {
    "prefix": "Storage::move",
    "body": [
      "Storage::move(${1:path}, ${2:target});$3"
    ],
    "description": "Move an existing file to a new location on the disk"
  },
  "Storage-name.sublime-snippet": {
    "prefix": "Storage::name",
    "body": [
      "Storage::name(${1:filePath});$2"
    ],
    "description": "Extract the file name from a file path."
  },
  "Storage-prepend.sublime-snippet": {
    "prefix": "Storage::prepend",
    "body": [
      "Storage::prepend(${1:filePath}, ${2:Prepended Text});$3"
    ],
    "description": "Insert content at the beginning of a file"
  },
  "Storage-put.sublime-snippet": {
    "prefix": "Storage::put",
    "body": [
      "Storage::put(${1:filePath}, ${2:\\$contents});$3"
    ],
    "description": "Store a file on disk"
  },
  "Storage-size.sublime-snippet": {
    "prefix": "Storage::size",
    "body": [
      "Storage::size(${1:filePath});$2"
    ],
    "description": "Get the size of the file in bytes"
  },
  "Storage-type.sublime-snippet": {
    "prefix": "Storage::type",
    "body": [
      "Storage::type(${1:filePath});$2"
    ],
    "description": "Get the file type of a given file."
  },
  "Str-uuid": {
    "prefix": "Str::uuid",
    "body": "Str::uuid();",
    "description": "UUID Methods"
  },
  "Str-orderedUuid": {
    "prefix": "Str::orderedUuid",
    "body": "Str::orderedUuid();",
    "description": "UUID Methods"
  },
  "View-composer.sublime-snippet": {
    "prefix": "View::composer",
    "body": [
      "view()->composer('${1:name}', function (${2:\\$view}) {",
      "    $3",
      "});"
    ],
    "description": "Define a View Composer"
  },
  "View-composerClass.sublime-snippet": {
    "prefix": "View::composerClass",
    "body": [
      "view()->composer('${1:name}', '${2:App\\Http\\ViewComposers\\SomeComposer}');$3"
    ],
    "description": "Define a Class-based View Composer"
  },
  "View-exists.sublime-snippet": {
    "prefix": "View::exists",
    "body": [
      "if (view()->exists('${1:view.name}'))",
      "{",
      "    $2",
      "}"
    ],
    "description": "Determine if a view exists"
  },
  "View-make.sublime-snippet": {
    "prefix": "View::make",
    "body": [
      "view('${1:view.name}', ${2:\\$data});$3"
    ],
    "description": "Create a View with Data"
  },
  "View-makeCompact.sublime-snippet": {
    "prefix": "View::makeCompact",
    "body": [
      "view('${1:view.name}', compact(${2:\\$data}));$3"
    ],
    "description": "Create a View, Pass Data with compact()"
  },
  "View-makeWith.sublime-snippet": {
    "prefix": "View::makeWith",
    "body": [
      "view(${1:'view.name'})->with('${2:key}', ${3:\\$value});$4"
    ],
    "description": "Create a View, Pass Data using with()"
  },
  "View-render.sublime-snippet": {
    "prefix": "View::render",
    "body": [
      "view(${1:'name'}, ${2:\\$data})->render();$3"
    ],
    "description": "Render a view with some data"
  },
  "View-share.sublime-snippet": {
    "prefix": "View::share",
    "body": [
      "view()->share('${1:key}', ${2:\\$value});$3"
    ],
    "description": "Share Data across all Views"
  }
}
